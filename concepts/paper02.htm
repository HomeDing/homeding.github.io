
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Software and Library Architecture</title>
  <script src="/pages.js"></script>
  <link content-type="text/css" href="/docstyle.css" rel="stylesheet"/>
  <script src="/story.js" type="module"></script>
  <link rel="icon" type="image/png" href="/favicon48.png" sizes="48x48">
  <meta name='description' content='Insights into the design of an IoT device,'>
  <meta name="google-site-verification" content="7tTF0t5uCMnyE6X31OIOQpcOf4QxWuODtyZLoVsKCEc"/>
  <meta name="msvalidate.01" content="7FC9C7BCD4002EBD89AAC2EF63D7B353"/>
</head>

<body class="sitelayout" style="--content-width:800px">
  <div class="navbar">
    <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 48 48" id="menuButton" class="button" style="height:1.4rem">
      <path fill="white" d="M0 8h48v6H0zm0 13h48v6H0zm0 13h48v6H0z"/>
    </svg>
    <a href="/index.htm" class="button">Home</a>
    <a href="/elements/index.htm" class="button">Elements</a>
    <a href="/boards/index.htm" class="button">Boards</a>
    <a href="/recipes/index.htm" class="button">Recipes</a>
  </div>
  
  <nav class="menu"></nav>

  <main>
    <h1>Software and Library Architecture</h1>

    

    <ol>
<li><a href="/concepts/paper01.htm">Building your own connected Things made easy</a></li>
<li><strong>Software Architecture</strong></li>
<li><a href="/concepts/paper03.htm">Elements and Actions</a></li>
<li><a href="/concepts/paper04.htm">Builtin Web server</a></li>
<li><a href="/concepts/paper05.htm">Device Discovery</a></li>
</ol>
<p>These are the functional blocks of a device based on the HomeDing library:</p>
<p><img src="/concepts/architectureblocks.png" alt="Internal software architecture blocks" title="w600"></p>
<p>The library provides a web server
as the <strong>door</strong> to the network that enables to use the UI from the files on the filesystem and by providing REST based services to interact with the device.</p>
<p>The firmware contains a collection of elements that deliver a specific functionality like probing a sensor or controlling a digital output pin. They can be
activated and configured by the configuration files. This allows flexible configurations and enhancements without re-programming the firmware to the device.</p>
<p>The build-in Web UI that comes with the examples can be used out of the box as it configures itself to show the active used elements and their data on a dashboard.</p>
<p>A micro implementation of a JSON parser and some utilities are provided for this central role.</p>
<h2>Building self-contained and autonomous Things</h2>
<p>In the market many Home Automation systems and gadgets are available
that require to buy, build or use a central system that controls the devices.</p>
<h3>No Cloud please – but as an option</h3>
<p>Amazon, Google and others are proving the central computing power on the internet “in the cloud” that are used by companies to build central portals to control the IoT devices e.g. by voice.
Power sockets or bulbs e.g. need to be connected to the internet all time and some of your personal data needs to be shared with the cloud providers.</p>
<p>Some of these systems offer real powerful features and cannot be easily replaced by a private system inside your household.</p>
<p>But without these cloud based systems your devices might not work or have some functional limitations.</p>
<p>Using these services may be something you consider for specific solutions but is is not required to connect to the internet when building Things that do not need such a service.
Therefore, you also do not need to register yourself or your thing anywhere. It is all yours.</p>
<h3>No Hub or central device required</h3>
<p>Some systems like Philips Hue system or the IKEA TRÅDFRI systems requires to buy a hub as a central controller because the Things in these systems cannot connect directly to the Home WLAN. They use another network protocol to communicate and the hub is required to „translate“ between these protocols like ZigBee or Z-Wave and the regular WLAN.</p>
<p>Because the processors today include the WLAN networking capabilities directly this kind of design is not required any more and is even a bad design because Things may fail to operate because of the possible central failure of the hub.</p>
<p>For simple solutions this also adds too much overhead and complexity to have a smart easy start building your own things.</p>
<h2>Elements</h2>
<p>The Elements are the implementation blocks for the adaption of specific sensors, actors, other IO attached modules and for more time and logic modules. They are created and initialized on demand by the board when reading the configuration files.</p>
<p>When creating the upload program for a device many elements can be included. As they are configured they will be activated by using the parameters from the configuration files.</p>
<p>For many devices the standard example contains already all the element implementations that are used by the recipes available in the documentation. These can be adopted by just modifying the configuration.</p>
<p>Some elements are started right after reading the configuration, some after the network is available and some when the local time was received.</p>
<h2>Configuration at runtime</h2>
<p>The standard board already includes a lot of Elements when being compiled. Therefore, it is possible to use them in a configuration without recompiling the program itself.</p>
<p>As the ESP chips offer a lot of memory this approach works fine. For compiling to different board layout like the ESP-01 board or the ESP8285 chip with less flash memory it is possible to compile with a reduced set of elements to make the program fit into memory. See more on this topic in the <a href="/examples/minimal.htm">minimal example</a></p>
<p>Be aware that the number of configured elements is also a limiting factor because every Element not only needs program space but also memory for variables.</p>
<p>The configuration of the HomeDing device is using in 2 files:</p>
<ul>
<li>
<p>The system, hardware related features and the network configuration is defined in the <code>env.json</code> file. This file contains the configuration of the system level elements and hardware related elements like</p>
<ul>
<li><a href="/elements/device.htm">Device Element</a></li>
<li><a href="/elements/ota.htm">OTA Element</a></li>
<li><a href="/elements/ssdp.htm">SSDP Element</a></li>
<li><a href="/elements/display/index.htm">Display Elements</a></li>
</ul>
<p>There is no real need to change this file frequently and it stays the same for a specific board. In the documentation about the boards I know you can find samples for typical env.json files.</p>
</li>
<li>
<p>The configuration of other elements is placed in the <code>config.json</code> file. This file can be updated to change the behavior of the device.</p>
</li>
<li>
<p>The web based configuration features will update the <code>config.json</code> file only.</p>
</li>
<li>
<p>The configuration is split into these 2 files this way to make sure the device can start and can be reached over the network even when the configuration of the non-system elements in <code>config.json</code> is corrupted.</p>
</li>
</ul>
<h2>Web based configuration</h2>
<p>Every device with a standard board can also host the functionality of a web interface that can be used to create or modify the configuration by dragging new elements into the activation area and changing the parameters.
For this level no programming skills are required.</p>
<p>It is also easy to implement new Elements or modify existing elements to create specific solutions based for other attached modules or to for specific functionality.</p>
<p>The base sketch of a device can also be modified for using very specific boards like ESP-01 boards that do not have full memory options available. Yu can find examples for this in the library.</p>
<h3>Web User Interface always built-in</h3>
<p>Instead it is possible to connect to a Thing directly to watch and control it by using a standard browser.</p>
<p>Things built with the HomeDing library support a programming interface (<a href="http://API.md">API.md</a>) that you can use by directly typing the requests and commands into the Address field and see the results on the Thing or as a response in the browser.</p>
<p>The standard interface provided by the HomeDing library allows to configure and control any internal Element out of thee box just by using the browser.</p>
<p>As an more advanced option it is possible to implement your own very specific Web User Interface using html, css and some javascript.</p>
<h2>Building must be easy</h2>
<p>The HomeDing library is some more than just a library that can be used within your sketches and also contains files for building an integrated web server and some specific configuration techniques.</p>
<p>Nevertheless the start to use this must be easy and without any problems.</p>
<p>The setup to use the HomeDing library is just the standard setup for ESP8266 boards:</p>
<ul>
<li>Download and install the Arduino Environment</li>
<li>Download and install the board</li>
<li>Download and install the SPIFFS plugin for supporting uploading files to the onboard filesystem</li>
</ul>
<p>After a setup of the Arduino environment only a few typical steps will be required to have the first Ding setup:</p>
<ul>
<li>Upload a sample sketch that doesn’t requires special Hardware or Libraries</li>
<li>Upload the Web files.</li>
</ul>
<p>Start browser and see…</p>
<h3>Next: <a href="/concepts/paper03.htm">Elements and Actions</a></h3>


      
        <h2>Tags</h2>
        <div class="taglist"><a href="/tag/implementation.htm">Implementation</a></div>
      
  </main>

  <script>
    var mbObj = document.querySelector('#menuButton');
    var navObj = document.querySelector('nav');
    mbObj.addEventListener('click', function (e) {
      navObj.classList.toggle('open');
    });
    lazyLoadHTM('nav', '/toc.htm');
  </script>

  <script type="module" async>
    import mermaid from "https://unpkg.com/mermaid@10/dist/mermaid.esm.min.mjs";
    document.addEventListener('DOMContentLoaded', mermaid.initialize({startOnLoad: true}));
  </script>

</body>
</html>