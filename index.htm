<!DOCTYPE html>
<html lang="en">
<!--
Markdown viewer SPA using
* http://marked.js.org/
* https://highlightjs.org/download/
-->

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="google-site-verification" content="7tTF0t5uCMnyE6X31OIOQpcOf4QxWuODtyZLoVsKCEc" />
  <meta name="msvalidate.01" content="7FC9C7BCD4002EBD89AAC2EF63D7B353" />
  <link rel="icon" type="image/png" href="favicon48.png" sizes="48x48">
  <meta name='description' content='Examples and documentation for the HomeDing IoT Library.'>
  <title>HomeDing Documentation</title>
  <link Content-Type="text/css" href="docstyle.css" rel="stylesheet" />
  <script src="md/markdown-it.min.js"></script>
  <script src="md/markdown-it-container.min.js"></script>
  <script src="md/highlight.pack.js"></script>
  <script src="pages.js"></script>
</head>

<body scroll="0" style="padding:0;">
  <div class="container-fluid">
    <div class="row u-header">
      <a href="/" title="Startpage"><img class="icon" src="i/default.svg" /></a>
      <h1>HomeDing</h1>
    </div>
  </div>
  <div class="row u-navbar" style="margin-bottom: 0;">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 48 48" id="menuButton" class="button" style="height:1.4rem">
      <path fill="white" d="M0 8h48v6H0zm0 13h48v6H0zm0 13h48v6H0z" />
    </svg>

    <!-- <a href="#" class="button"><img src="menu.svg"></a> -->
    <a href="#" class="button">Home</a>
    <a href="#page=concepts/paper01.md" class="button">Concepts</a>
    <a href="#page=/elements/overview.md" class="button">Elements</a>
    <a href="#page=boards.md" class="button">Boards</a>
    <a href="#page=recipes/index.md" class="button">Recipes</a>
  </div>
  <nav class="inpage"></nav>
  <main class="container-fluid">
    <div class="s-md"></div>
  </main>

  <script>
    var mbObj = document.querySelector('#menuButton');
    var navObj = document.querySelector('nav');

    mbObj.addEventListener('click', function (e) {
      navObj.classList.toggle('open');
    });
    if (window.innerWidth > 880)
      navObj.classList.add('open');

    // setup Markdown-IT default with options 
    var md = new markdownit('default', {
      html: true,
      breaks: false,
      linkify: true,
      langPrefix: 'hljs language-',
      highlight: function (str, lang) {
        if (!hljs.getLanguage(lang))
          lang = "plaintext";
        var t = hljs.highlight(lang, str);
        return (t.value);
      }
    });


    function renderPlainCard() {
      return '<div class="plaincard">';
    }

    function renderIconCard(icon, title, linkFolder, link) {
      var div = '<div class="iconcard">';
      var img = '<svg class="icon"><use href="/icons.svg#' + icon + '"></use></svg>';

      if ((title) && (linkFolder) && (link)) {
        return (div
          + `<a href="#page=/${linkFolder}/${link}.md">`
          + img + '<h3>' + title + '</h3>' + '</a>');
      } else {
        return (div + img);
      }
    }

    function renderImageCard(image, title, linkFolder, link) {
      var div = '<div class="imgcard">';
      var img = `<img src="/${linkFolder}/${image}.jpg">`;

      if ((title) && (linkFolder) && (link)) {
        return (div
          + `<a href="#page=/${linkFolder}/${link}.md">`
          + img + '<h3>' + title + '</h3>' + '</a>');
      } else {
        return (div + img);
      }
    }

    // excerpts on any page
    // ::: excerpt [icon]
    var mdc = new markdownitContainer(md, 'excerpt', {
      render: function (tokens, idx) {
        var t = tokens[idx];
        if (t.nesting === 1) {
          var m = t.info.trim().match(/^\s*excerpt\s+(.*)$/);
          if (m) {
            return renderIconCard(m[1]);
          } else {
            return renderPlainCard();
          }
        } else {
          return '</div>\n';
        }
      }
    });


    // card for boards in boards folder
    // ::: board image
    new markdownitContainer(md, 'board', {
      render: function (tokens, idx) {
        var t = tokens[idx];
        if (t.nesting === 1) {
          var m = t.info.trim().match(/^\s*board\s+(.*)$/);
          return renderImageCard(m[1], undefined, 'boards', m[1]);
        } else {
          return '</div>\n';
        }
      }
    });


    // card for elements in elements folder
    // ::: element title [icon]
    new markdownitContainer(md, 'element', {
      render: function (tokens, idx) {
        var t = tokens[idx];
        if (t.nesting === 1) {
          var m = t.info.trim().match(/^\s*element\s+(\S+)\s*(\S*)/);
          if (m[2]) {
            return renderIconCard(m[2], m[1], 'elements', m[1]);
          } else {
            return renderIconCard('no', m[1], 'elements', m[1]);
          }

        } else {
          return '</div>\n';
        }
      }
    });


    // card for sensors in sensors folder
    // ::: sensor image
    new markdownitContainer(md, 'sensor', {
      render: function (tokens, idx) {
        var t = tokens[idx];
        if (t.nesting === 1) {
          var m = t.info.trim().match(/^\s*sensor\s+(\S+)/);
          return renderImageCard(m[1], undefined, 'sensors', m[1]);
        } else {
          return '</div>\n';
        }
      }
    });

    new markdownitContainer(md, 'warning', {
      render: function (tokens, idx) {
        var t = tokens[idx];
        if (t.nesting === 1) {
          var m = t.info.trim().match(/^\s*warning\s+(.*)$/);
          return '<div class="warning"><h3>Warning</h3>\n';
        } else {
          return '</div>\n';
        }
      }
    });

    // simplified YAML parser supporting only a key:value object. 
    function extractFrontData(txt) {
      var fd = {};
      var fMatch = txt
        .match(/^-{3,}\s*[\r\n]+([^\0]*)[\r\n]+-{3,}[\r\n]*/);

      if (fMatch) {
        var fText = fMatch[1].replace(/[\r\n]+/g, "\n");

        // reformat multiline values
        fText = fText.replaceAll(/>\s*(\n  [^\n]+)+(?=\n*$|\n\S)/g, m => {
          return (m.substring(1).replace(/\n\s*/g, ' '));
        });

        var matches = fText.matchAll(/^(?<key>\S+)\s*:\s*(.*)$/gm);
        for (const match of matches) {
          fd[match[1]] = match[2];
        }
        return ({
          length: fMatch[0].length,
          data: fd
        });

      } else {
        return ({ length: 0, data: {} });
      }
    } // extractFrontData


    function getHashParam(param, defValue) {
      var h = window.location.hash;
      if (h) {
        var params = h.substr(1).split('&');
        for (i = 0; i < params.length; i++) {
          var p = params[i].split('=');
          if (p[0] == param) return p[1];
        } // for
      }
      return defValue;
    } // getHashParam

    /** load a JSON using a URL / rest service or static file */
    function loadFile(url, loadCallback, errorCallback) {
      var req = new XMLHttpRequest();
      req.overrideMimeType('application/text');
      req.open('GET', url);
      // req.onload  = func;
      req.onload = function (x) {
        if (this.readyState == 4) {
          if (this.status == 200) {
            loadCallback(this.responseText);
          } else {
            errorCallback(this);
          }
        }
      };
      req.onerror = errorCallback;
      req.send(null);
    } // loadFile

    function forAllNodeList(nodeList, callbackFn) {
      for (var n = 0; n < nodeList.length; n++) {
        callbackFn(nodeList[n]);
      }
    } // forAllNodeList()

    // === Markdown Loader ===

    var mdClass = {
      _checking: false,

      // show given text as html.
      setText: function (fName, txt) {

        // extract front data
        var fData = extractFrontData(txt);

        if (fData.length > 0) {
          txt = txt.substring(fData.length);
          // replace using njk syntax 
          txt = txt.replaceAll(/\{\{\s*data.(\S+)\s*\}\}/g, (m, key) => fData.data[key]);

          // replace meta tags in header
          if (fData.data.title) document.title = fData.data.title;

          if (fData.data.tags) {
            var e = document.head.querySelector('meta[name=keywords]');
            if (e) { e.content = fData.data.tags; }
          }

          if (fData.data.description) {
            var e = document.head.querySelector('meta[name=description]');
            if (e) { e.content = fData.data.description; }
          }
        }

        var hText = md.render(txt);

        // modify markdown links to work:
        hText = hText.replace(/href="([\w\-\/]+).md"/g, 'href="#page=$1.md"');
        hText = hText.replace(/href="([\w\-\/]+)"/g, 'href="#page=$1.md"');
        this.innerHTML = hText;

        // size Images
        forAllNodeList(
          this.querySelectorAll('img'),
          function (aObj) {
            aObj.addEventListener('click', function (evt) {
              window.open(evt.target.src, "img");
            });
          }.bind(this)
        );

      },

      // init, when slide behavior is attached.
      init: function () {
        this.onhashchange(); // initial navigation
        this._checking = false;
      },

      // check for #page=xxx.md
      onhashchange: function (/* evt */) {
        var pName = getHashParam('page', 'index.md').toLowerCase();

        loadFile(
          pName,
          function (txt) {
            this.setText(pName, txt);
            window.scrollTo(0, 0);
          }.bind(this),

          function (x) {
            this.setText(pName, '>> File with name ' + pName + ' not found.');
          }.bind(this)
        );
      }
    };

    lazyLoadMD('nav', 'toc.md');

    // manually attach md container
    var mdObj = document.querySelector('.s-md');
    if (mdObj) {
      mdObj.init = mdClass.init;
      mdObj.setText = mdClass.setText;
      mdObj.onhashchange = mdClass.onhashchange;
      window.addEventListener('hashchange', mdObj.onhashchange.bind(mdObj));
      mdObj.init();
    }

    // function iLink(evt) {
    //   const aObj = evt.target;
    //   console.log(aObj.href);
    //   evt.preventDefault();
    // }

    // document.querySelectorAll('nav').forEach(el => {
    //   el.addEventListener('click', iLink);
    // })



  </script>
</body>

</html>