<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="google-site-verification" content="7tTF0t5uCMnyE6X31OIOQpcOf4QxWuODtyZLoVsKCEc" />
  <meta name="msvalidate.01" content="7FC9C7BCD4002EBD89AAC2EF63D7B353" />
  <link rel="icon" type="image/png" href="favicon48.png" sizes="48x48">
  <meta name='description' content=''>
  <title>Implementing Elements</title>
  <link Content-Type="text/css" href="/docstyle.css" rel="stylesheet" />
  <script src="/pages.js"></script>
</head>

<body scroll="0" style="padding:0;">
  <div class="u-header">
    <a href="/" title="Startpage"><img class="icon" src="/i/default.svg" /></a>
    <h1>HomeDing</h1>
  </div>

  <div class="u-navbar" style="margin-bottom: 0;">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 48 48" id="menuButton" class="button" style="height:1.4rem">
      <path fill="white" d="M0 8h48v6H0zm0 13h48v6H0zm0 13h48v6H0z" />
    </svg>

    <a href="/index.htm" class="button">Home</a>
    <a href="/concepts/index.htm" class="button">Concepts</a>
    <a href="/elements/index.htm" class="button">Elements</a>
    <a href="/boards/index.htm" class="button">Boards</a>
    <a href="/recipes/index.htm" class="button">Recipes</a>
  </div>
  <nav class="inpage x  open"></nav>

  <main style="padding:1rem">
    <h1>Implementing Elements</h1>
<p>Implementing Elements is very easy because they are designed similar to the standard Arduino Sketches
by implementing a <code>setup()</code> and a <code>loop()</code> method as usual.</p>
<p>By further steps this can seamlessly extended an Element implementation by</p>
<ul>
<li>participating in the configuration mechanism by implementing the <code>set()</code> method</li>
<li>the status reporting by implementing the <code>pushState()</code> method.</li>
<li>temporary start/stop of functionality by implementing the <code>start()</code> and <code>term()</code> methods.</li>
</ul>
<p>In addition Elements can expose very specific REST services to expose element specific APIs.</p>
<h2>Minimal Element implementations</h2>
<p>Usually Arduino sketches only have one global setup and one global loop method.
Within the Homeding library every element will have these methods
so they need to be wrapped into a class.</p>
<p>There is a &quot;MiniElement.h&quot; file in the DevDing example to show
how an Element can be implemented just like a &quot;normal&quot; Arduino Sketch:</p>
<pre class="language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">MiniElement</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Element</span></span> <span class="token punctuation">{</span><br><br>  <span class="token keyword">unsigned</span> <span class="token keyword">long</span> lastTime<span class="token punctuation">;</span><br><br>  <span class="token comment">/**<br>   * @brief setup the functionality.<br>   */</span><br>  <span class="token keyword">void</span> <span class="token function">setup</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token comment">// Setup code here...</span><br>    lastTime <span class="token operator">=</span> <span class="token function">millis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><br>    Serial<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Setup done."</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>  <span class="token punctuation">}</span><br><br>  <span class="token comment">/**<br>   * @brief run the functionality.<br>   */</span><br>  <span class="token keyword">void</span> <span class="token function">loop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">millis</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> lastTime <span class="token operator">+</span> <span class="token number">4000</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>      Serial<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Blink.."</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>      lastTime <span class="token operator">=</span> <span class="token function">millis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token punctuation">}</span><br>  <span class="token punctuation">}</span><br><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre>
<p>in the global setup() method a instance of this class can be added to the homeding setup:</p>
<pre class="language-cpp"><code class="language-cpp"><span class="token class-name">ElementRegistry</span><span class="token double-colon punctuation">::</span><span class="token function">_addElement</span><span class="token punctuation">(</span><span class="token string">"mini/1"</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token function">MiniElement</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p>The Homeding library implements a <em>cooperative</em> approach of having many active elements at once.</p>
<p>Therefore it is very important NOT to waste any time in the <code>loop()</code> method like using delay(),
long running calculations or loops waiting for anything. The homeding library will give
every element the chance to execute in the <code>loop()</code> method and all elements must be
cooperative in this.</p>
<h2>Element implementations with full functionality</h2>
<p>A more useful implementation of an element requires only a few methods to be implemented to participate more in the ecosystem:</p>
<ul>
<li>set()</li>
<li>start()</li>
<li>loop()</li>
<li>pushState()</li>
</ul>
<p>The <a href="/elements/digitalin.htm">DigitalIn Element</a> can be examined as an example.</p>
<p>It uses the <code>set()</code> method to retrieve all the possible configuration settings
to enable detecting digital input levels from a GPIO pin.</p>
<p>The <code>start()</code> method configures the GPIO pin in the required way when a valid pin is specified.</p>
<p>The <code>loop()</code> method constantly watches the input level and triggers an event in the case the value has changed to inform other elements.</p>
<p>The <code>pushstate()</code> makes the current value available to the Web UI frontend in the state service.</p>
<h3>set() - setting properties and receiving actions</h3>
<p>When the Element is crated and even later when a action is send to the Element a key and value is passed in the <code>set</code> method. This is the the only method that needs to process incoming data. It checks the passed key and then takes the data or executes the action.</p>
<p>Some Element implementations will only require to implement the setting parameters given from the configuration and others also may react to actions to trigger a functionality or to modify a dynamic property of the Element.</p>
<p>Samples can be found in the provided Element implementations.</p>
<ul>
<li>The ButtonElement only needs to process the properties for the setup of the implementation like the hardware pin and the triggered actions.</li>
<li>The TimerElement also implements the „next“ and „start“ action that need no parameter but can be used when the timer is active to manipulate the actual state.</li>
</ul>
<p>When the key parameter is not known to the element itself the <code>set</code> method of the base Element class should be called.</p>
<h3>start() - initialize</h3>
<p>This method is called after all config properties have been set on all elements and the setup() method was called.</p>
<p>Here the initialization of the hardware or the used library should be implemented.</p>
<p>This is also the place to check that the given configuration is meaningful and valid.</p>
<p>When everything is good so far the start method of the base Element class must be called. The member variable <code>active</code> of the Element will be set to true.</p>
<h3>PushState() – return the actual dynamic values</h3>
<p>Sometimes it is required to get the inner actual properties of an Element because they need to be displayed somewhere or are fetched from another Element for some reasons.</p>
<p>The <code>pushState</code> method is handling this by sending all properties to a provided callback method.</p>
<p>The <code>pushState</code> method only needs to pass those properties that will change while the element
while the properties coming from the configuration that will never change are not reported this way.</p>
<p>This is not a limitation because the configuration values are available anyhow by reading the config.json file.</p>
<p><a href="/dev/webserver.htm">The build-in WebServer</a> offers a restfull endpoint to retrieve these values from the browser or from remote.</p>
<p>Samples can be found in the provided Element implementations.</p>
<ul>
<li>The ButtonElement only needs to push the current level of the Button.</li>
<li>The TimerElement is reporting the current state and level of the timer and the current (relative) time from the start.</li>
</ul>
<p>There are even Elements like the RemoteElement that do not ned to implement this method because they have no inner dynamic variables.</p>
<p>The <code>pushState</code> method of the base Element class should also be called</p>
<h3>loop() – so something meaningful</h3>
<p>As you know from Arduino sketches the <code>loop</code> method is the place where all the activity of a sketch is implemented.
The same with the elements. Here is the place to have some useful implementation. Examples are:</p>
<ul>
<li>Check some input and create a event eventually (like the ButtonElement does)</li>
<li>Check timing conditions (like the TimerElement does)</li>
<li>Read a sensor from time to time (like the DHTElement does)</li>
</ul>
<p>The <code>loop</code> method is only called for elements in the active state. These are the Elements that did not initialize properly (likely because of a wrong configuration or missing hardware).</p>
<h2>Advanced Element implementation</h2>
<p>Some Elements will have some more advanced features and therefore some more virtual methods can be implemented in the Elements:</p>
<h3>init() - basic initialization</h3>
<p>The <code>init</code> method is called immediately after a Element is created and before the first configuration property is passed to the Element implementation.</p>
<p>It is preferred to initialize component or class not in the creation method of the class because:</p>
<ul>
<li>some initialization routines will start after the creation of static classes</li>
<li>some initialization of libraries require parameters that are likely to be available after the configuration is passed.</li>
</ul>
<p>In the HomeDing Library therefore the creation is primarily done in the <code>init</code> method and not in the class creator methods. (e.g. see <a href="https://stackoverflow.com/questions/18806141/move-object-creation-to-setup-function-of-arduino">https://stackoverflow.com/questions/18806141/move-object-creation-to-setup-function-of-arduino</a>).</p>
<p>This method is implemented in the base Element class and stores the passed board class reference to the common <code>_board</code> member variable.</p>
<h3>term() – deactivate this Element</h3>
<p>The <code>term</code> method is the logical counterpart to the <code>init</code> method and terminates all functionality from the Element.</p>
<p>The allocated resources should be freed (e.g. disabling attached modules or releasing used I/O lines).</p>
<h3>Register a WebService Endpoint</h3>
<p>Inside the setup() method it is possible to register a webserver endpoint that exposes specific functionality of an element as a service.</p>
<p>An example can be found in the diag element in the DevDing example</p>
<pre class="language-cpp"><code class="language-cpp">  _board<span class="token operator">-></span>server<span class="token operator">-></span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">"/diag"</span><span class="token punctuation">,</span> HTTP_GET<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token keyword">this</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    _board<span class="token operator">-></span>server<span class="token operator">-></span><span class="token function">send</span><span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">,</span> <span class="token string">"text/plain"</span><span class="token punctuation">,</span> <span class="token function">_scanI2C</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p>The <code>_scanI2C()</code> method scans the local I2C bus for responsive devices and returns a String with some details.</p>
<p>This service can be called using the url: <code>http://&lt;devicename&gt;/diag</code>.</p>
<h2>Common Element member variables and helper methods</h2>
<p>The basic Element class also provides some useful variables and helper functions.</p>
<h3>id</h3>
<p>The <code>id</code> of the Element. Visible to anyone.</p>
<h3>active – marking the Element to be actively used</h3>
<p>The Member variable <code>active</code> is used to mark any Element as properly initialized and ready to be used. This is done during the <code>start</code> method and can be revoked using the <code>term</code> method</p>
<h3>_board</h3>
<p>A reference to the board the Element is on.</p>
<h3>_atob()</h3>
<p>Return a boolean value from a string.</p>
<h3>_atotime()</h3>
<p>Return a time value from a string.</p>
<h3>_stricmp</h3>
<p>Replacement of the CPP stricmp used to compare identifiers and ids as the method not available on Arduino.</p>

  </main>

  <script>
    var mbObj = document.querySelector('#menuButton');
    var navObj = document.querySelector('nav');

    navObj.classList.toggle('open', (window.innerWidth > 880));

    mbObj.addEventListener('click', function (e) {
      navObj.classList.toggle('open');
    });

    lazyLoadHTM('nav', '/toc.htm');
  </script>
  
  </body>

</html>