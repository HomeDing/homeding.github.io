<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="google-site-verification" content="7tTF0t5uCMnyE6X31OIOQpcOf4QxWuODtyZLoVsKCEc" />
  <meta name="msvalidate.01" content="7FC9C7BCD4002EBD89AAC2EF63D7B353" />
  <link rel="icon" type="image/png" href="/favicon48.png" sizes="48x48">
  <title>NO-TITLE</title>
  <meta name='description' content='Examples and documentation for the HomeDing IoT Library'>
  <link Content-Type="text/css" href="/docstyle.css" rel="stylesheet" />
  <script src="/pages.js"></script>
</head>

<body scroll="0" style="padding:0;">
  <div class="u-navbar" style="margin-bottom: 0;">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 48 48" id="menuButton" class="button" style="height:1.4rem">
      <path fill="white" d="M0 8h48v6H0zm0 13h48v6H0zm0 13h48v6H0z" />
    </svg>

    <a href="/index.htm" class="button">Home</a>
    <a href="/elements/index.htm" class="button">Elements</a>
    <a href="/boards/index.htm" class="button">Boards</a>
    <a href="/recipes/index.htm" class="button">Recipes</a>
  </div>

  <nav></nav>

  <main style="padding:1rem;max-width: 800px;">
    <h1>Displays using a GFX Library</h1>
<p>The display drivers for pixel based displays in the HomeDing Library
are using drivers based on a GFX library.</p>
<p>The functionality of the GFX library is used to “draw” all kind of simple things to the displays like pixels, lines, rectangles
and pure text. This is often done by having a equivalent of the display memory in a main memory buffer.</p>
<h2>How drawing is implemented</h2>
<p>To show information on a display a set of widgets aka. DisplayOutputElements is available.</p>
<p>By setting the properties or values of these Elements they are marked to be drawn on the display and the DisplayAdapter implementation has also been flagged for redraw.</p>
<p>This allows changing multiple properties at the same time without intermediate draw activity and especially helps combining changes
on slow displays like E-Paper displays.</p>
<p>Drawing starts when no action is queued in the board and the loop function of all elements has been called.</p>
<pre class="mermaid">flowchart LR&#10;  DisplayOutputElement[&quot;Display#60;Output#62;Element&quot;]&#10;  ChangeValue --&gt; DisplayOutputElement --&gt; |set needRedraw| DisplayOutputElement&#10;</pre>
<p>Some display chip specific implementations directly change the memory of the display, some will update an internal copy of the display memory.</p>
<pre class="mermaid">flowchart LR&#10;  DisplayOutputElement[&quot;Display#60;Output#62;Element&quot;]&#10;  Base([Base-Loop]) --&gt; |startFlush| DisplayAdapter&#10;  DisplayAdapter --&gt;|draw| DisplayOutputElement&#10;  DisplayOutputElement --&gt; |draw| GFX([GFX]) --&gt; Memory&#10;</pre>
<p>After all Output Elements are drawn the flush() is initiated from the Display Adapter to send the buffered copy to the display for the displays using a display memory copy.</p>
<pre class="mermaid">flowchart LR&#10;  DisplayChipAdapter[&quot;Display#60;Chip#62;Adapter&quot;]&#10;  Bus([&quot;Bus&quot;])&#10;&#10;  Base([Base-Loop]) --&gt; |startFlush| DisplayAdapter&#10;  DisplayAdapter --&gt; |flush| DisplayChipAdapter --&gt; Bus --&gt; Chip&#10;  DisplayChipAdapter -.-&gt; |read| Memory &#10;</pre>
<p>The communication to the Display Chip
uses a
bus like I2C, SPI or 16-bit data to flush the updated memory into the chip.</p>
<h2>GFX Libraries</h2>
<p>There are several GFX library implementions for Arduino available that are used to draw text, lines
and fill rectangles.</p>
<ul>
<li><a href="https://github.com/adafruit/Adafruit-GFX-Library">Adafruit GFX Library</a></li>
<li><a href="https://github.com/lovyan03/LovyanGFX">LovyanGFX</a></li>
<li><strong><a href="https://github.com/moononournation/Arduino_GFX">GFX Library for Arduino</a></strong></li>
<li><a href="https://github.com/codewitch-honey-crisis/gfx">honeythecodewitch.com/gfx</a></li>
</ul>
<p>These libraries provide very similar functionality but cover different display types and communication busses.</p>
<p>The HomeDing library today uses the GFX Library for Arduino as it has specific bus implementations for ESP32 based devices
and I2C bus support together with small displays was added.</p>
<h2>Display Adapter</h2>
<p>Between the DisplayOutputElement and the GFX library the DisplayAdapter (for GFX) offers some simple drawing functions. These
are used by the DisplayOutputElements as they check some HomeDing specifics:</p>
<p>The GFX libraries differ in their implementation in detail and some primitives are using bounding box parameters others with and
height. This is unified by the adapter drawing functions.</p>
<ul>
<li>When the key colors RGB_UNDEFINED or RGB_TRANSPARENT are used for drawing, the GFX functions are not called.</li>
<li>When the coordinates are outside the display area the GFX functions are not called.</li>
<li>The signature of the drawing functions use a boundingBox parameter where applicable.</li>
</ul>
<h2>Using Display Output Elements</h2>
<p>The DisplayItems are the Elements to configure what should be drawn on the display.</p>
<p>Part of the core library you have</p>
<ul>
<li><a href="/elements/display/text.htm">Display Text Element</a></li>
<li><a href="/elements/display/dot.htm">Display Dot Element</a></li>
<li><a href="/elements/display/line.htm">Display Line Element</a></li>
<li><a href="/elements/display/rect.htm">Display Rect Element</a></li>
<li><a href="/elements/display/button.htm">Display Button Element</a></li>
</ul>
<p>The <a href="/elements/display/text.htm">Display Text Element</a> and <a href="/elements/display/dot.htm">Display Dot Element</a> can also be used with the character based displays that can show text only like the <a href="/elements/display/lcd.htm">LCD Display</a>. These displays are not using a GFX library.</p>
<h2>Color parameters for Display Output Elements</h2>
<p>The Display Output Elements can be configured with 3 color properties: <code>color</code>, <code>background</code> and <code>border</code>. These are used as default values for all
configured Output Elements.</p>
<p>The color “none” can be used to remove the color value.</p>
<table>
<thead>
<tr>
<th>Output Element</th>
<th>“color”:</th>
<th>“background”:</th>
<th>“border”:</th>
</tr>
</thead>
<tbody>
<tr>
<td>Line</td>
<td>line color</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Text</td>
<td>text color</td>
<td>background color</td>
<td>border color</td>
</tr>
<tr>
<td>Rect</td>
<td></td>
<td>background color</td>
<td>border color</td>
</tr>
<tr>
<td>Button</td>
<td>text color</td>
<td>background color</td>
<td>border color</td>
</tr>
</tbody>
</table>
<h2>More Display Output Elements</h2>
<p>The [Display Example] folder has an advanced set of Display Output Elements that can be used with the ESP32 processors that allow more resource consuming drawings.</p>
<p>They are implemented by using the (internal)    <a href="/gfxdraw-library.htm">gfxDraw Library</a>  that supports vector oriented drawings on top of a GFX library.</p>
<p>See <a href="/gfxdraw-library.htm">gfxDraw Library</a> for further details.</p>
<!--
In the Display Example you can find
* [Display Bar Element]
-->
<h2>Drawing on a gfx display</h2>
<p>It is possible to directly draw objects on the GFX display. When changing a value or the pointer of a clock, you need to erase
the existing drawings by changing the pixels to a defined background color before the new drawing.</p>
<p>But things get more complex when overlapping objects must be drawn. The object in the background must be drawn even when not
changed. Also when changing a background object the objects in the front must be drawn again.</p>
<p>Here the declarative nature of elements helps by just marking elements with changed properties as to be redrawn and coordinate
the effective drawing of all overlapping objects.</p>
<p>In the base class DisplayAdapter the <code>startFlush</code> function by default first calculates the combined bounding box of the Elements that have
been changed and then draws all Elements that are at least partly inside this box in the correct order.</p>
<p>This approach works fine when elements are placed on background elements that support
rendering using a clipping rectangle.</p>
<p>Especially the rect Element can be used as a background for text Elements.</p>
<p>When drawing an Element</p>
<h2>Flush data to a display</h2>
<p>There are displays that allow a fast way of sending data to the display chip that is shown immediately like on TFT panels. On
the other hand there are e-paper displays that require some seconds for update and frequent updates should be avoided.</p>
<p>To reduce the number of transfers of the changed data to the display the flush() operation is not directly triggered by the
drawings but will be triggered when there is no current action pending for delivery.</p>
<p>The display adapter can check if the display needs some redraw before transferring the data. For displays like E-Paper it is
possible to delay the data transfer even further by using the <code>delayflush</code> parameter.</p>
<p>A good documentation of a GFX library can be found at <a href="https://learn.adafruit.com/adafruit-GFX-graphics-library">https://learn.adafruit.com/adafruit-GFX-graphics-library</a>.</p>
<p><a href="https://github.com/adafruit/Adafruit_EPD/blob/master/src/Adafruit_EPD.cpp">https://github.com/adafruit/Adafruit_EPD/blob/master/src/Adafruit_EPD.cpp</a></p>
<h2>See also</h2>
<ul>
<li><a href="fonts.md">Fonts</a></li>
<li><a href="https://learn.adafruit.com/adafruit-GFX-graphics-library">https://learn.adafruit.com/adafruit-GFX-graphics-library</a></li>
</ul>

  </main>

  <script>
    const param = {
      MENU_MIN_WIDTH: 1030
    };

    var mbObj = document.querySelector('#menuButton');
    var navObj = document.querySelector('nav');

   if (window.innerWidth > param.MENU_MIN_WIDTH) {
      // menu is inside the page
      navObj.classList.add('open');
      navObj.classList.add('inpage');
    }

    mbObj.addEventListener('click', function (e) {
      navObj.classList.toggle('open');
    });

    lazyLoadHTM('nav', '/toc.htm');
  </script>
  
  </body>

</html>