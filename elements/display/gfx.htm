
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Displays using a GFX Library</title>
  <script src="/pages.js"></script>
  <link content-type="text/css" href="/docstyle.css" rel="stylesheet">
  <script src="/story.js" type="module"></script>
  <link rel="icon" type="image/png" href="/favicon48.png" sizes="48x48">
  <meta name="description" content="Parameters to configure display support.">
  <meta name="google-site-verification" content="7tTF0t5uCMnyE6X31OIOQpcOf4QxWuODtyZLoVsKCEc">
  <meta name="msvalidate.01" content="7FC9C7BCD4002EBD89AAC2EF63D7B353">
</head>

<body class="sitelayout">
  <div class="navbar">
    <button id="menu" popovertarget="my-menu">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 48 48">
        <path fill="white" d="M0 8h48v6H0zm0 13h48v6H0zm0 13h48v6H0z"></path>
      </svg>
    </button>
    <a href="/index.htm" class="button">Home</a>
    <a href="/elements/index.htm" class="button">Elements</a>
    <a href="/boards/index.htm" class="button">Boards</a>
    <a href="/recipes/index.htm" class="button">Recipes</a>
    
  </div>
  
  <nav popover="auto" id="my-menu" class="menu"></nav>

  <main>
    <h1>Displays using a GFX Library</h1>

    
      <div class="card-container horizontal text" style="--card-height:5rem;--card-image-size:5rem;">
        <div class="card">
          
          <div class="body">
            <p>Using GFX library</p>

          </div>
        </div>
      </div>
    

    <p>The display drivers for pixel based displays in the HomeDing Library are using display driver implementation based on a GFX library.</p>
<p>The typical functionality of a GFX library is to “draw” all kind of simple things to the displays like pixels, lines,
rectangles and pure text.  This is often done by having a equivalent of the display memory in a main memory buffer but
sometimes the drawn pixel are sent to the device as they are drawn.</p>
<p>However the drawing functions directly use the driver implementation and therefore lack of some possibilities required for several cases:</p>
<ul>
<li>When only a part of a widget is required to be drawn a clipping area or rectlangle cannot be applied to avoid drawing on same pixels.</li>
<li>ome drivers always send the whole display memory to the display requiring a lot of CPU cycles and time.</li>
<li>Drawing primitives can use solid colors only.</li>
</ul>
<p>The HomeDing library includes several Elements for Widget implementations that draw by using callback functions as
described in the <a href="https://github.com/mathertel/gfxDraw">gfxDraw Library</a>.</p>
<p>The GFX library that includes the display specific output routines and bus drivers must only support a setPixel function.</p>
<p>To display multiple elements / Widgets on one display 2 different drawing modes are implemented:</p>
<h2>Simple drawing mode</h2>
<p>This drawing implementation fits good into devives with limited cpu and memory capacities.</p>
<p>It is optimized for drawing simple graphic elements on the device without the need to buffer the current display in memory.</p>
<p>Drawing a graphic element is assuming the following situation:</p>
<ul>
<li>None of the elements do overlap with their drawing areas / bounding boxes.</li>
<li>There is a common background color for all elements.</li>
<li>Elements can „erase“ any previous drawing by simply filling the full drawing area with the background color and do a full redraw.</li>
</ul>
<p>With these conditions drawing widgets may do their internal optimization to avoid full drawing sequences.</p>
<ul>
<li>All elements that are marked for redraw are drawn in any order.</li>
<li>When a new logical page is displayed the surface is erased with the background color and all widgets on the page are drawn.</li>
</ul>
<h2>Full drawing mode</h2>
<p>This drawing implementation fits good for devices that offer enough resources for complex graphical elements.</p>
<p>This includes drawing overlapping elements with the support of current clipping areas and dynamic bounding boxes.</p>
<ul>
<li>All elements that are marked for redraw will trigger the redraw of all objects covering the area in the order defined by the configuration.</li>
<li>The display implementation offering the getColor(x,y) functionality can be used.</li>
<li>The clipping box will be set ao widgets will be able to optimise drawing by only setting pixels within the clipping area.</li>
<li>Any drawing outside the clipping area will not be effective.</li>
</ul>
<p>SetPixel</p>
<p>GetPixel
Set clipping area</p>
<h2>How drawing is implemented</h2>
<h3>Changing DisplayOutputElements</h3>
<p>To display anything on a display the DisplayOutputElements (widgets) have been implemented.
When changing properties or values of these Elements</p>
<ul>
<li>The DisplayOutputElements is marked with <code>needsDraw</code> to be drawn</li>
<li>The DisplayAdapter is marked to start a redraw next time.</li>
</ul>
<p>This allows changing multiple properties at the same time without triggering immediate draw activity and especially
helps combining changes on slow displays like E-Paper displays.</p>
<h3>Redraw Procedure</h3>
<p>Drawing starts when no action is queued in the board and the loop function of all elements has been called.</p>
<p>In the base class of the DisplayAdapter 2 approaches of drawing the marked and potential additional elements are implemented:</p>
<p>The simpler way will only draw those DisplayOutputElements that are marked with <code>needsDraw</code> in the defined order.  The
DisplayOutputElements that are marked with <code>isOpaque</code> will also trigger that the display background is drawn before the
element itself gets drawn.</p>
<p>The additional available algorithm will detect overlapping elements and triggers the drawing also on those elements that have a overlap with the marked elements.
This may result in more drawing activity.</p>
<h3>Redraw Flush</h3>
<p>There are 2 approaches to draw on a display</p>
<ul>
<li>Some driver implementations directly change the memory of the display</li>
<li>Some driver implementations draw on an internal copy of the display memory and flush it out when drawing is completed.</li>
</ul>
<p>After all Output Elements are drawn, the <code>flush()</code> method is called on the DisplayAdapter to send the buffered copy to
the display for the displays using a display memory copy.  The <code>flush()</code> will always be called on the DisplayAdapter
even when no flush activity needs to be executed.</p>
<h2>GFX Libraries</h2>
<p>There are several GFX library implementions for Arduino available that are used to draw text, lines
and fill rectangles.</p>
<ul>
<li><a href="https://github.com/adafruit/Adafruit-GFX-Library">Adafruit GFX Library</a></li>
<li><a href="https://github.com/lovyan03/LovyanGFX">LovyanGFX</a></li>
<li><strong><a href="https://github.com/moononournation/Arduino_GFX">GFX Library for Arduino</a></strong></li>
<li><a href="https://github.com/codewitch-honey-crisis/gfx">honeythecodewitch.com/gfx</a></li>
</ul>
<p>These libraries provide very similar functionality but cover different display types and communication busses.</p>
<p>The HomeDing library today uses the GFX Library for Arduino as it has specific bus implementations for ESP32 based devices
and I2C bus support together with small displays was added.</p>
<h2>Display Adapter</h2>
<p>Between the DisplayOutputElement and the GFX library the DisplayAdapter (for GFX) offers some simple drawing functions. These
are used by the DisplayOutputElements as they check some HomeDing specifics:</p>
<p>The GFX libraries differ in their implementation in detail and some primitives are using bounding box parameters others with and
height. This is unified by the adapter drawing functions.</p>
<ul>
<li>When the key colors RGB_UNDEFINED or RGB_TRANSPARENT are used for drawing, the GFX functions are not called.</li>
<li>When the coordinates are outside the display area the GFX functions are not called.</li>
<li>The signature of the drawing functions use a boundingBox parameter where applicable.</li>
</ul>
<h2>Using Display Output Elements</h2>
<p>The DisplayItems are the Elements to configure what should be drawn on the display.</p>
<p>Part of the core library you have</p>
<ul>
<li><a href="/elements/display/text.htm">Display Text Element</a></li>
<li><a href="/elements/display/dot.htm">Display Dot Element</a></li>
<li><a href="/elements/display/line.htm">Display Line Element</a></li>
<li><a href="/elements/display/rect.htm">Display Rect Element</a></li>
<li><a href="/elements/display/button.htm">Display Button Element</a></li>
</ul>
<p>The <a href="/elements/display/text.htm">Display Text Element</a> and <a href="/elements/display/dot.htm">Display Dot Element</a> can also be used with the character based displays that can show text only like the <a href="/elements/display/lcd.htm">LCD Display</a>. These displays are not using a GFX library.</p>
<h2>Color parameters for Display Output Elements</h2>
<p>The Display Output Elements can be configured with 3 color properties: <code>color</code>, <code>background</code> and <code>border</code>. These are used as default values for all
configured Output Elements.</p>
<p>The color “none” can be used to remove the color value.</p>
<table>
<thead>
<tr>
<th>Output Element</th>
<th>“color”:</th>
<th>“background”:</th>
<th>“border”:</th>
</tr>
</thead>
<tbody>
<tr>
<td>Line</td>
<td>line color</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Text</td>
<td>text color</td>
<td>background color</td>
<td>border color</td>
</tr>
<tr>
<td>Rect</td>
<td></td>
<td>background color</td>
<td>border color</td>
</tr>
<tr>
<td>Button</td>
<td>text color</td>
<td>background color</td>
<td>border color</td>
</tr>
</tbody>
</table>
<h2>More Display Output Elements</h2>
<p>The [Display Example] folder has an advanced set of Display Output Elements that can be used with the ESP32 processors that allow more resource consuming drawings.</p>
<p>They are implemented by using the (internal)    <a href="/gfxdraw-library.htm">gfxDraw Library</a>  that supports vector oriented drawings on top of a GFX library.</p>
<p>See <a href="/gfxdraw-library.htm">gfxDraw Library</a> for further details.</p>
<!--
In the Display Example you can find
* [Display Bar Element]
-->
<h2>Drawing on a gfx display</h2>
<p>It is possible to directly draw objects on the GFX display. When changing a value or the pointer of a clock, you need to erase
the existing drawings by changing the pixels to a defined background color before the new drawing.</p>
<p>But things get more complex when overlapping objects must be drawn. The object in the background must be drawn even when not
changed. Also when changing a background object the objects in the front must be drawn again.</p>
<p>Here the declarative nature of elements helps by just marking elements with changed properties as to be redrawn and coordinate
the effective drawing of all overlapping objects.</p>
<p>In the base class DisplayAdapter the <code>startFlush</code> function by default first calculates the combined bounding box of the Elements that have
been changed and then draws all Elements that are at least partly inside this box in the correct order.</p>
<p>This approach works fine when elements are placed on background elements that support
rendering using a clipping rectangle.</p>
<p>Especially the rect Element can be used as a background for text Elements.</p>
<p>When drawing an Element</p>
<h2>Flush data to a display</h2>
<p>There are displays that allow a fast way of sending data to the display chip that is shown immediately like on TFT panels. On
the other hand there are e-paper displays that require some seconds for update and frequent updates should be avoided.</p>
<p>To reduce the number of transfers of the changed data to the display the flush() operation is not directly triggered by the
drawings but will be triggered when there is no current action pending for delivery.</p>
<p>The display adapter can check if the display needs some redraw before transferring the data. For displays like E-Paper it is
possible to delay the data transfer even further by using the <code>delayflush</code> parameter.</p>
<p>A good documentation of a GFX library can be found at <a href="https://learn.adafruit.com/adafruit-GFX-graphics-library">https://learn.adafruit.com/adafruit-GFX-graphics-library</a>.</p>
<p><a href="https://github.com/adafruit/Adafruit_EPD/blob/master/src/Adafruit_EPD.cpp">https://github.com/adafruit/Adafruit_EPD/blob/master/src/Adafruit_EPD.cpp</a></p>
<h2>See also</h2>
<ul>
<li><a href="fonts.htm">Fonts</a></li>
<li><a href="https://learn.adafruit.com/adafruit-GFX-graphics-library">https://learn.adafruit.com/adafruit-GFX-graphics-library</a></li>
</ul>


      
        <h2>Tags</h2>
        <div class="taglist"><a href="/tag/element.htm">Element</a><a href="/tag/display.htm">Display</a><a href="/tag/gfx.htm">Gfx</a><a href="/tag/wip.htm">Wip</a></div>
      
  </main>

  <script>
    

    var navObj = document.querySelector('nav');
    lazyLoadHTM('nav', '/toc.htm');
  </script>

</body>
</html>